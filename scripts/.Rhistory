c(0.1,1.5,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,1.5,0.2,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.2,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,2.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.2,0.3,0.2,0.1,0.1,0.2,0.1,2.0,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,1.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,1.5))
# simulate class 2 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl2 <-mvrnorm(110, mu=c(6,7,1,3,2,8,3,8,2,5), Sigma=Sigma2)
##########################################################
######## define covariance matrix of v1-v10 in class 3 ###
Sigma3 <- rbind(c(1.0,0.1,0.2,0.1,0.1,0.3,0.1,0.3,0.1,0.1),
c(0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,2.2,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,2.0,0.1,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.1,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,1.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.3,0.3,0.2,0.1,0.1,0.2,0.1,1.2,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,3.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,2.0))
# simulate class 3 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl3 <-mvrnorm(90, mu=c(2,5,8,7,5,2,1,4,9,8), Sigma=Sigma3)
##########################################################
### convert matrices to data.frame objects & add a class nr
cl1 <- as.data.frame(cl1)
cl1$class <-rep(1,100)
cl2 <- as.data.frame(cl2)
cl2$class <-rep(2,110)
cl3 <- as.data.frame(cl3)
cl3$class <- rep(3,90)
View(cl3)
# merge the three class dataframes and add ID numbers
dat1 <- rbind(cl1,cl2,cl3)
colnames(dat1) <- c('var1', 'var2', 'var3', 'var4', 'var5',
'var6', 'var7', 'var8', 'var9', 'var10',
'class')
dat1$class <- as.factor(dat1$class)
View(dat1)
dat1$id <- seq(1,300,1)
##########################################################
### add a little stochastic noise for increased realism ;)
dat1$var1 <- dat1$var1 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var2 <- dat1$var2 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var3 <- dat1$var3 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var4 <- dat1$var4 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var5 <- dat1$var5 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var6 <- dat1$var6 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var7 <- dat1$var7 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var8 <- dat1$var8 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var9 <- dat1$var9 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var10 <- dat1$var10 + rnorm(n=300, mean=0, sd=sqrt(1))
# Visualize real quick
ggplot(data, aes(group=id, color=class)) +
geom_line()
# Visualize real quick
library(ggplot2)
ggplot(data, aes(group=id, color=class)) +
geom_line()
ggplot(dat1, aes(group=id, color=class)) +
geom_line()
library(babynames)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
idvar= c('id'))
View(dat2)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
v.names=c('Value'),
idvar= c('id'))
# Visualize real quick
library(ggplot2)
ggplot(dat2, aes(x = variables, y = Value, group=id, color=class)) +
geom_line()
########### MClust ####
library(mclust)
install.packages("mclust")
mnames <- c("EEI", "EEE", "VVI", "VVV")
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
########### MClust ####
library(mclust)
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
View(mod_g1_9)
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC
mod_g1_9$loglik
mod_g1_9$df
BIC = 2(−5951.275) − 42(log(300)) = −12142.11
BIC = 2(-5951.275) - 42(log(300))
BIC = 2*(-5951.275) - 42(log(300))
42(log(300))
42*(log(300))
BIC = 2*(-5951.275) - 42*(log(300))
BIC
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
mod_g1_9$z
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification
mod_g1_9$uncertainty
# Check max and mean uncertainty over all participants
max(mod_g1_9$uncertainty)
mean(mod_g1_9$uncertainty)
# Plot or tabulate uncertainty per class to gain further insight
cprob <- cbind(mod_g1_9$z, mod_g1_9$classification)
cprob <- as.data.frame(cprob)
colnames(cprob) <- c("prob (class 1)", "prob (class 2)", "prob (class 3)", "class")
aggregate(cprob[, 1:3], list(cprob$class), mean)
install.packages("tidyLPA")
# Predict LPA models with 1-9 classes, with an EI config:
suppressMessages(library(tidyLPA))
suppressMessages(mod_1c_v1 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = 1))
mod_1c_v1
# Optimal model variant
mod_g1_9$modelName
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC # Maybe weird that negative, but: BIC = 2(Loglikelihood) − df(log(n))
mod_g1_9$loglik
mod_g1_9$df
BIC = 2*(-5951.275) - 42*(log(300)) # See?, same BIC!
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification # Leading to a class classification matrix; posterior allocation
mod_g1_9$uncertainty # WATCH OUT, only use classification if it is a clear cut case which class a participant belongs to. Else; use uncertainty indices.
suppressMessages(mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = c(1,2,3,6)))
# Let's try to fix all variable covariances to zero
mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9, variances = "equal",
covariances = "zero")
mod_1c_v2$model_1_class_2$fit
# Compare model fits (for v1)
comp <- suppressWarnings(compare_solutions(mod_1c_v1))
comp$fits
comp$best
library(arrow) # Parquets
library(lme4)
library(car)
library(emmeans)
library(ggplot2)
library(dplyr)
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # Load document where functions are stored
nAGQ = 1
plotPrefix <- "../figures/"
##### Loading data #####
# Audio Data
audioData <-
as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet"))
# Limesurvey Data
questionData <- as.data.frame(read.csv("../loc_data/QuestionnaireResults.csv"))
questionData$participantNum = questionData$Participant.Number # Change name for merge
colnames(questionData)[which(names(questionData) == "DASS.SCORES")] <- "DASS.Depression"
colnames(questionData)[which(names(questionData) == "X")] <- "DASS.Anxiety"
colnames(questionData)[which(names(questionData) == "X.1")] <- "DASS.Stress"
colnames(questionData)[which(names(questionData) == "RRS.SCORES")] <- "RRS.SCORE"
colnames(questionData)[which(names(questionData) == "X.2")] <- "RRS.Reflection"
colnames(questionData)[which(names(questionData) == "X.3")] <- "RRS.Brooding"
audioData = merge(audioData, questionData, by = "participantNum") # Merge audioData with trait questionnaires
# Behavioral Data
behavioralData <-
as.data.frame(read_parquet("../loc_data/behavioralData_CYBB_MIST.parquet"))
behavioralData$participantNum = behavioralData$participant_ID # Change name for merge
behavioralData <- behavioralData[c("participantNum", # Create smaller dataframe with only relevant variables
"Mean_SCRS_Baseline", "Mean_SCRS_Control", "Mean_SCRS_Stress",
"Mean_VAS_NA_Baseline", "Mean_VAS_PAA_Baseline", "Mean_VAS_PSA_Baseline", "VAS_Stress_Baseline",
"Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PSA_Control_Post_Rest", "VAS_Stress_Control_Post_Rest",
"Mean_VAS_NA_Control", "Mean_VAS_PAA_Control", "Mean_VAS_PSA_Control", "VAS_Stress_Control",
"Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PSA_Stress_Post_Rest", "VAS_Stress_Stress_Post_Rest",
"Mean_VAS_NA_Stress", "Mean_VAS_PAA_Stress", "Mean_VAS_PSA_Stress", "VAS_Stress_Stress",
"taskType")]
behavioralDataLong <- reshape(behavioralData, direction='long', # Transform dataframe to long format
varying=list(c("Mean_VAS_NA_Baseline", "Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_NA_Control", "Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_NA_Stress"),
c("Mean_VAS_PAA_Baseline", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PAA_Control", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PAA_Stress"),
c("Mean_VAS_PSA_Baseline", "Mean_VAS_PSA_Control_Post_Rest", "Mean_VAS_PSA_Control", "Mean_VAS_PSA_Stress_Post_Rest", "Mean_VAS_PSA_Stress"),
c("VAS_Stress_Baseline", "VAS_Stress_Control_Post_Rest", "VAS_Stress_Control", "VAS_Stress_Stress_Post_Rest", "VAS_Stress_Stress")),
timevar='fileNum',
times=c('baseline', 'control rest', 'control', 'stress rest', 'stress'),
v.names=c('VAS_NA', 'VAS_PAA', 'VAS_PSA', 'VAS_Stress'),
idvar= c('participantNum', 'taskType'))
# This is easier to work with to plot over time and needed to merge with behavioralData
audioData$fileNum[audioData$fileName == "audio_picture_baseline.wav"] = "baseline"
audioData$fileNum[audioData$fileName == "audio_referential_control.wav"] = "control"
audioData$fileNum[audioData$fileName == "audio_picture_control.wav"] = "control rest"
audioData$fileNum[audioData$fileName == "audio_referential_stress.wav"] = "stress"
audioData$fileNum[audioData$fileName == "audio_picture_stress.wav"] = "stress rest"
audioData = merge(audioData, behavioralDataLong, by = c("participantNum","taskType", "fileNum"))
audioData$paradigm[grepl("referential", audioData$fileName)] = "Referential"
audioData$paradigm[grepl("picture", audioData$fileName)] = "Pic Describe"
audioData <- audioData %>% # Factorize relevant variables
transform(participantNum = as.factor(participantNum),
taskType = as.factor(taskType),
descriptionType = as.factor(descriptionType),
experimentPhase = as.factor(experimentPhase),
Sex = as.factor(Sex),
Age = as.double(Age),
paradigm = as.factor(paradigm),
DASS.Depression = as.double(DASS.Depression),
DASS.Anxiety = as.double(DASS.Anxiety),
DASS.Stress = as.double(DASS.Stress),
RRS.SCORE = as.double(RRS.SCORE),
RRS.Reflection = as.double(RRS.Reflection),
RRS.Brooding = as.double(RRS.Brooding))
audioData$fileNum <- ordered(audioData$fileNum, levels = c('baseline', 'control', 'control rest', 'stress', 'stress rest')) # Factorize (ordered) moment
levels(audioData$fileNum) <- list("Baseline"  = "baseline", "Control Task" = "control", "Control Rest" = "control rest", "Stress Task" = "stress", "Stress Rest" = "stress rest")
levels(audioData$taskType) <- list(Cyberball = "cybb", MIST = "mist")
# Create a dataframe omitting all other time moments
audioData = filter(audioData, fileNum == "Control Task" | fileNum == "Stress Task")
# Physiological Data (couldn't do that earlier, because different time moments)
physiologicalData <- as.data.frame(read_parquet("../loc_data/df_feat_tot.parquet"))
physiologicalData$taskType[physiologicalData$condition == "mist"] = "MIST"
physiologicalData$taskType[physiologicalData$condition == "cybb"] = "Cyberball"
physiologicalData$participantNum = physiologicalData$patient_id
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST stress"] = "Stress Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball stress"] = "Stress Task"
physiologicalData <- physiologicalData[c("participantNum", "taskType", "fileNum", "duration_s", "rmssd", "sdnn",
"mean_hr", "max_hr", "min_hr", "std_hr", "lf", "hf", "lf_hf_ratio", "total_power",
"SCRR", "phasic_area", "tonic_mean", "phasic_area_normalized", "mean_EDA_SQI")]
physiologicalData = filter(physiologicalData, fileNum == "Control Task" | fileNum == "Stress Task")
#  Present in physiological, but not in rest
physiologicalData$participantNum[!physiologicalData$participantNum %in% audioData$participantNum]
# Present in rest, but not in physiological
audioData$participantNum[!audioData$participantNum %in% physiologicalData$participantNum]
# Merge to final dataframe
allData = merge(audioData, physiologicalData, by = c("participantNum","taskType", "fileNum"))
summary(allData)
####### Speech features #######
# Speech features: F0 ######
formula <- 'F0semitoneFrom27.5Hz_sma3nz_amean ~ fileNum * taskType + Sex + (1|participantNum)' # Declare formula
datatemp <- audioData[c('F0semitoneFrom27.5Hz_sma3nz_amean', 'fileNum', 'taskType', 'Sex', 'paradigm', 'participantNum')] # Clean dataframe to check with Jens
View(questionData)
#                                    #
# Analysis of Audio and Self-reports #
#       Social stressor data         #
#                                    #
######################################
# This code uses premade csv for speech variables and self-reports
# Here we perform data cleanup, analysis, and visualisation
# Author: Mitchel Kappen
# 12-4-2022
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
library(yarrr)
library(lme4)
library(emmeans)
library(pander)
library(reshape)
library(lme4)
library(lmerTest)
library(pander)
library(effects)
library(effectsize)
library(ggpubr)
library(car)
library(ggplot2)
library(arrow)
library(tibble)
library(dplyr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # This is a file in the same directory where you can stash your functions so you can save them there and have them together
options(contrasts = c("contr.sum","contr.poly")) #use this for the p value of the t test
#####  General settings #####
nAGQ = 1 # Glmer setting
pvalues = c() # Create a variable to store all p-values to correct later
plotPrefix <- "../figures/" # Define directory to store visualisations
data <- as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet")) # Read dataframe containing audio features and self-reports
##### Clean data up a bit #####
data$participantNum <- as.factor(data$participantNum)
agesex <- as.data.frame(read.csv("../loc_data/SexAge.csv")) # Read dataframe containing participants' Sex and Age
data <- merge(data, agesex, by = c("participantNum")) # Add demographics to main dataframe
# Add final condition names including 'baseline'
data$condition[data$fileNum == 0] = 'baseline'
data$condition[data$fileNum == 1|data$fileNum == 2|data$fileNum == 3] = 'Control'
data$condition[data$fileNum == 5|data$fileNum == 6|data$fileNum == 7] = 'Negative'
data$condition[data$fileNum == 4|data$fileNum == 8] = 'Rest'
# Get relevant data
dataBackup = data # Backup data so we can go back to this whenever
data = data[data$condition ==  'Control' | data$condition == 'Negative',] # Get only control and negative feedback data (kick out resting blocks)
data = data[data$HNRdBACF_sma3nz_amean > 0, ] # Kick out all the lines with negative HNR, that means the signal is too noisy to trust
# Factorize final relevant variables
data$condition <- as.factor(data$condition)
data$Sex <- as.factor(data$Sex)
View(data)
######################################
#                                    #
# Analysis of Audio and Self-reports #
#       Social stressor data         #
#                                    #
######################################
# This code uses premade csv for speech variables and self-reports
# Here we perform data cleanup, analysis, and visualisation
# Author: Mitchel Kappen
# 12-4-2022
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
library(yarrr)
library(lme4)
library(emmeans)
library(pander)
library(reshape)
library(lme4)
library(lmerTest)
library(pander)
library(effects)
library(effectsize)
library(ggpubr)
library(car)
library(ggplot2)
library(arrow)
library(tibble)
library(dplyr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # This is a file in the same directory where you can stash your functions so you can save them there and have them together
options(contrasts = c("contr.sum","contr.poly")) #use this for the p value of the t test
#####  General settings #####
nAGQ = 1 # Glmer setting
pvalues = c() # Create a variable to store all p-values to correct later
plotPrefix <- "../figures/" # Define directory to store visualisations
data <- as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet")) # Read dataframe containing audio features and self-reports
##### Clean data up a bit #####
data$participantNum <- as.factor(data$participantNum)
agesex <- as.data.frame(read.csv("../loc_data/SexAge.csv")) # Read dataframe containing participants' Sex and Age
data <- merge(data, agesex, by = c("participantNum")) # Add demographics to main dataframe
# Add final condition names including 'baseline'
data$condition[data$fileNum == 0] = 'baseline'
data$condition[data$fileNum == 1|data$fileNum == 2|data$fileNum == 3] = 'Control'
data$condition[data$fileNum == 5|data$fileNum == 6|data$fileNum == 7] = 'Negative'
data$condition[data$fileNum == 4|data$fileNum == 8] = 'Rest'
# Get relevant data
dataBackup = data # Backup data so we can go back to this whenever
data = data[data$condition ==  'Control' | data$condition == 'Negative',] # Get only control and negative feedback data (kick out resting blocks)
data = data[data$HNRdBACF_sma3nz_amean > 0, ] # Kick out all the lines with negative HNR, that means the signal is too noisy to trust
# Factorize final relevant variables
data$condition <- as.factor(data$condition)
data$Sex <- as.factor(data$Sex)
##############################
#                            #
#     All Analysis   V1      #
#    Audio and Physiology    #
#       Cyberball-MIST       #
#                            #
#############################
#
# Author: Mitchel Kappen
# 15-6-2022
library(arrow) # Parquets
library(lme4)
library(car)
library(emmeans)
library(ggplot2)
library(dplyr)
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
source("functions.R") # Load document where functions are stored
nAGQ = 1
plotPrefix <- "../figures/"
##### Loading data #####
# Audio Data
audioData <-
as.data.frame(read_parquet("../loc_data/df_gemaps_func.parquet"))
# Limesurvey Data
questionData <- as.data.frame(read.csv("../loc_data/QuestionnaireResults.csv"))
questionData$participantNum = questionData$Participant.Number # Change name for merge
colnames(questionData)[which(names(questionData) == "DASS.SCORES")] <- "DASS.Depression"
colnames(questionData)[which(names(questionData) == "X")] <- "DASS.Anxiety"
colnames(questionData)[which(names(questionData) == "X.1")] <- "DASS.Stress"
colnames(questionData)[which(names(questionData) == "RRS.SCORES")] <- "RRS.SCORE"
colnames(questionData)[which(names(questionData) == "X.2")] <- "RRS.Reflection"
colnames(questionData)[which(names(questionData) == "X.3")] <- "RRS.Brooding"
audioData = merge(audioData, questionData, by = "participantNum") # Merge audioData with trait questionnaires
# Behavioral Data
behavioralData <-
as.data.frame(read_parquet("../loc_data/behavioralData_CYBB_MIST.parquet"))
behavioralData$participantNum = behavioralData$participant_ID # Change name for merge
behavioralData <- behavioralData[c("participantNum", # Create smaller dataframe with only relevant variables
"Mean_SCRS_Baseline", "Mean_SCRS_Control", "Mean_SCRS_Stress",
"Mean_VAS_NA_Baseline", "Mean_VAS_PAA_Baseline", "Mean_VAS_PSA_Baseline", "VAS_Stress_Baseline",
"Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PSA_Control_Post_Rest", "VAS_Stress_Control_Post_Rest",
"Mean_VAS_NA_Control", "Mean_VAS_PAA_Control", "Mean_VAS_PSA_Control", "VAS_Stress_Control",
"Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PSA_Stress_Post_Rest", "VAS_Stress_Stress_Post_Rest",
"Mean_VAS_NA_Stress", "Mean_VAS_PAA_Stress", "Mean_VAS_PSA_Stress", "VAS_Stress_Stress",
"taskType")]
behavioralDataLong <- reshape(behavioralData, direction='long', # Transform dataframe to long format
varying=list(c("Mean_VAS_NA_Baseline", "Mean_VAS_NA_Control_Post_Rest", "Mean_VAS_NA_Control", "Mean_VAS_NA_Stress_Post_Rest", "Mean_VAS_NA_Stress"),
c("Mean_VAS_PAA_Baseline", "Mean_VAS_PAA_Control_Post_Rest", "Mean_VAS_PAA_Control", "Mean_VAS_PAA_Stress_Post_Rest", "Mean_VAS_PAA_Stress"),
c("Mean_VAS_PSA_Baseline", "Mean_VAS_PSA_Control_Post_Rest", "Mean_VAS_PSA_Control", "Mean_VAS_PSA_Stress_Post_Rest", "Mean_VAS_PSA_Stress"),
c("VAS_Stress_Baseline", "VAS_Stress_Control_Post_Rest", "VAS_Stress_Control", "VAS_Stress_Stress_Post_Rest", "VAS_Stress_Stress")),
timevar='fileNum',
times=c('baseline', 'control rest', 'control', 'stress rest', 'stress'),
v.names=c('VAS_NA', 'VAS_PAA', 'VAS_PSA', 'VAS_Stress'),
idvar= c('participantNum', 'taskType'))
# This is easier to work with to plot over time and needed to merge with behavioralData
audioData$fileNum[audioData$fileName == "audio_picture_baseline.wav"] = "baseline"
audioData$fileNum[audioData$fileName == "audio_referential_control.wav"] = "control"
audioData$fileNum[audioData$fileName == "audio_picture_control.wav"] = "control rest"
audioData$fileNum[audioData$fileName == "audio_referential_stress.wav"] = "stress"
audioData$fileNum[audioData$fileName == "audio_picture_stress.wav"] = "stress rest"
audioData = merge(audioData, behavioralDataLong, by = c("participantNum","taskType", "fileNum"))
audioData$paradigm[grepl("referential", audioData$fileName)] = "Referential"
audioData$paradigm[grepl("picture", audioData$fileName)] = "Pic Describe"
audioData <- audioData %>% # Factorize relevant variables
transform(participantNum = as.factor(participantNum),
taskType = as.factor(taskType),
descriptionType = as.factor(descriptionType),
experimentPhase = as.factor(experimentPhase),
Sex = as.factor(Sex),
Age = as.double(Age),
paradigm = as.factor(paradigm),
DASS.Depression = as.double(DASS.Depression),
DASS.Anxiety = as.double(DASS.Anxiety),
DASS.Stress = as.double(DASS.Stress),
RRS.SCORE = as.double(RRS.SCORE),
RRS.Reflection = as.double(RRS.Reflection),
RRS.Brooding = as.double(RRS.Brooding))
audioData$fileNum <- ordered(audioData$fileNum, levels = c('baseline', 'control', 'control rest', 'stress', 'stress rest')) # Factorize (ordered) moment
levels(audioData$fileNum) <- list("Baseline"  = "baseline", "Control Task" = "control", "Control Rest" = "control rest", "Stress Task" = "stress", "Stress Rest" = "stress rest")
levels(audioData$taskType) <- list(Cyberball = "cybb", MIST = "mist")
# Create a dataframe omitting all other time moments
audioData = filter(audioData, fileNum == "Control Task" | fileNum == "Stress Task")
# Physiological Data (couldn't do that earlier, because different time moments)
physiologicalData <- as.data.frame(read_parquet("../loc_data/df_feat_tot.parquet"))
physiologicalData$taskType[physiologicalData$condition == "mist"] = "MIST"
physiologicalData$taskType[physiologicalData$condition == "cybb"] = "Cyberball"
physiologicalData$participantNum = physiologicalData$patient_id
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start MIST stress"] = "Stress Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball control"] = "Control Task"
physiologicalData$fileNum[physiologicalData$trigger == "Start cyberball stress"] = "Stress Task"
physiologicalData <- physiologicalData[c("participantNum", "taskType", "fileNum", "duration_s", "rmssd", "sdnn",
"mean_hr", "max_hr", "min_hr", "std_hr", "lf", "hf", "lf_hf_ratio", "total_power",
"SCRR", "phasic_area", "tonic_mean", "phasic_area_normalized", "mean_EDA_SQI")]
physiologicalData = filter(physiologicalData, fileNum == "Control Task" | fileNum == "Stress Task")
#  Present in physiological, but not in rest
physiologicalData$participantNum[!physiologicalData$participantNum %in% audioData$participantNum]
# Present in rest, but not in physiological
audioData$participantNum[!audioData$participantNum %in% physiologicalData$participantNum]
# Merge to final dataframe
allData = merge(audioData, physiologicalData, by = c("participantNum","taskType", "fileNum"))
summary(allData)
View(questionData)
##############################
#                            #
#     Audio Analysis V1      #
#       Cyberball-MIST       #
#                            #
#############################
#
# Author: Mitchel Kappen
# 6-4-2022
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
BASEPATH <- "Z:/shares/ghep_lab/2021_VanhollebekeKappen_EEGStudy2_MIST_Cyberball_Audio/"
plotPrefix <- paste0(BASEPATH, "Data/Interim/Audio/figures/")
##### Loading data #####
audioData <-
as.data.frame(read_parquet(paste0(BASEPATH,"Data/Raw/Audio/df_gemaps_func.parquet")))
audioData <- audioData %>%
transform(participantNum = as.factor(participantNum),
taskType = as.factor(taskType),
descriptionType = as.factor(descriptionType),
experimentPhase = as.factor(experimentPhase))
summary(audioData)
