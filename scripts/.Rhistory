inf.b.col = "black",  # Inf border col
avg.line.col = "black",  # avg line col
bar.f.col = gray(.8),  # bar filling color
point.pch = 21,
point.bg = "white",
point.col = "black",
point.cex = .7,
xlab="",
)
}, height=600)
output$plotmeans <-renderPlot({
if (grepl('Arousal', input$formula_choice) &grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew', 'Moment'))
p3 <- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMSScoreNew))+
geom_flat_violin (aes(fill=PMSScoreNew), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
geom_boxplot(aes(x=Moment, y=Arousal, fill=PMSScoreNew), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Arousal, group=PMSScoreNew, colour=PMSScoreNew), size=1.5)+
geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Arousal, group = PMSScoreNew, fill= PMSScoreNew), shape = 21, size=6)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
annotate('text', x=1, y=105, label='*', size=8)+
annotate('text', x=2, y=105, label='*', size=8)+
geom_segment(aes(x = 0.97, y = 103, xend = 1.03, yend = 103), size= 2)+
geom_segment(aes(x = 1.97, y = 103, xend = 2.03, yend = 103), size= 2)+
ggtitle('Arousal ~ PMSScoreNew * TestMoment')
p3
}else if (grepl('Valence', input$formula_choice) & grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew', 'Moment'))
p3 <- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMSScoreNew))+
geom_flat_violin (aes(fill=PMSScoreNew), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
geom_boxplot(aes(x=Moment, y=Valence, fill=PMSScoreNew), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Valence, group=PMSScoreNew, colour=PMSScoreNew), size=1.5)+
geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Valence, group = PMSScoreNew, fill=PMSScoreNew), shape = 21, size=6)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Valence~PMSScoreNew * TestMoment')
p3
}
else if (grepl('Arousal', input$formula_choice) & !grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew'))
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Arousal)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Arousal, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew)+.2, y = Arousal, fill=PMSScoreNew), shape = 21, size=6)+
geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Arousal), size=1, colour='black')+
geom_segment(aes(x = 1.2, y = 103, xend = 2.2, yend = 103), size= 1.7)+
# annotate('text', x=1.6, y=105, label=sprintf("\n%s\n", p_pms()), size=10)+
annotate('text', x=1.6, y=105, label='*', size=10)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Arousal~PMSScoreNew')
# coord_flip()
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Arousal)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Arousal, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew), y = Arousal, fill=PMSScoreNew), shape = 21, size=6)+
# geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Arousal), size=1, colour='black')+
geom_segment(aes(x = 1, y = 103, xend = 2, yend = 103), size= 1.7)+
# annotate('text', x=1.6, y=105, label=sprintf("\n%s\n", p_pms()), size=10)+
annotate('text', x=1.6, y=105, label='*', size=10)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Arousal~PMSScoreNew')
# coord_flip()
p1
}else {
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew'))
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Valence)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust= 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Valence, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew)+.2, y = Valence, fill=PMSScoreNew), shape = 21, size=6)+
geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Valence), size=1, colour='black')+
# annotate('text', x=1.6, y=70, label=sprintf("\n%s\n", p_pms()), size=8)+
ggtitle('Valence~PMSScoreNew')
# coord_flip()
p1
#
# p<- ggplot(dataBig2, aes(x=PMSScoreNew, y=Valence, fill=PMSScoreNew))+
#     geom_split_violin(adjust=1.5,alpha=.5, colour=NA )+
#   geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
#   geom_boxplot(aes(x = PMSScoreNew, y = Valence, fill = PMSScoreNew),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
#   geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew), y = Valence, group = PMSScoreNew, fill = PMSScoreNew), position=position_dodge(0.2), shape = 21, size=4)+
#   ggtitle('Valence ~ PMS')
# p
#
#
#
}
}, height=600)
output$splitviolin <-renderPlot({
if (grepl('Arousal', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew', 'Moment'))
p<- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMSScoreNew))+
geom_split_violin(adjust =1.5, alpha=.5, colour= NA)+
geom_boxplot(aes(x = Moment, y = Arousal, fill = PMSScoreNew), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(Moment), y = Arousal, group = PMSScoreNew, fill = PMSScoreNew), position= position_dodge(0.2), shape = 21, size=4)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
annotate('text', x=1, y=105, label='*', size=8)+
annotate('text', x=2, y=105, label='*', size=8)+
geom_segment(aes(x = 0.955, y = 103, xend = 1.055, yend = 103), size= 2)+
geom_segment(aes(x = 1.955, y = 103, xend = 2.055, yend = 103), size= 2)+
ggtitle('Arousal ~ PMS * TestMoment')
p
} else if (grepl('Valence', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew', 'Moment'))
p<- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMSScoreNew))+
geom_split_violin(adjust=1.5,alpha=.5, colour=NA)+
geom_boxplot(aes(x = Moment, y = Valence, fill = PMSScoreNew), position= position_dodge(0.2) ,outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(Moment), y = Valence, group = PMSScoreNew, fill = PMSScoreNew), position=position_dodge(0.2), shape = 21, size=4)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Valence ~ PMS * TestMoment')
p
}
}, height=600)
output$int_means <- renderPlot({
if ((grepl('Valence', input$formula_choice))){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('TestMoment', 'PMSScoreNew'))# this function gives sd, se mean and default 95% C.I.
p<-ggplot(dmean, aes(x=TestMoment, y=Valence, colour=PMSScoreNew, group=PMSScoreNew)) +
geom_errorbar(aes(ymin=Valence-standard_error(Valence), ymax=Valence+standard_error(Valence), width=.1))+
geom_line() +
geom_point(size=3)
p} else {
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('TestMoment', 'PMSScoreNew'))# this function gives sd, se mean and default 95% C.I.
p<-ggplot(dmean, aes(x=TestMoment, y=Arousal, colour=PMSScoreNew, group=PMSScoreNew)) +
geom_errorbar(aes(ymin=Arousal-standard_error(Arousal), ymax=Arousal+standard_error(Arousal), width=.1))+
geom_line() +
geom_point(size=3)
p}
})
models <- reactive({ # we need to create this within a reactive context to be able to access the formula_choice
m <- c()
# Formula <- 'DASS_Stress ~ PMSScoreNew * TestMoment + (1|Subject)'
Formula <- paste0(input$formula_choice, '+ (1|Subject)')
tryCatch(
{ d0.1 <- lmer(Formula,data=dataBig2); # if this formula works
m <- c(m, d1=d0.1)}, #we add this
error=function(e){})
tryCatch(
{ d0.2 <- glmer(Formula,data=dataBig2, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d1=d0.2)},
error=function(e){})
tryCatch(
{ d0.3 <- glmer(Formula,data=dataBig2, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d3=d0.3)},
error=function(e){})
tryCatch(
{ d0.4 <- glmer(Formula,data=dataBig2, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d4=d0.4)},
error=function(e){})
tryCatch(
{ d0.5 <- glmer(Formula,data=dataBig2, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d5=d0.5) },
error=function(e){})
tryCatch(
{ d0.6 <- glmer(Formula,data=dataBig2, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d6=d0.6) },
error=function(e){})
tryCatch(
{ d0.7 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
models <- c(models, d7=d0.7) },
error=function(e){})
tryCatch(
{ d0.8 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d8=d0.8) },
error=function(e){})
tryCatch(
{ d0.9 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d9=d0.9) },
error=function(e){})
m
})
output$table <-renderTable({
modelNames<-c()
tabel<-c()
for (i in 1:length(models())){
modelNames<-c(modelNames, names(models()[i]))
AIC<-AIC(models()[[i]])
tabel <- c (tabel, round(AIC))}
chosenModel = modelNames[which(tabel == min(tabel))]
tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
tabel
})
p<-reactive({
tabel<-c()
for (i in 1:length(models())){
AIC<- AIC(models()[[i]])
tabel <- c(tabel,round(AIC))}
chosenModel<-models()[which(tabel == min(tabel))]
Anova_1 <- Anova(chosenModel[[1]])
cat(sprintf("\nAnova\n"))
Anova_1
#            tabel<-c()
# for (i in 1:length(m)){
#     AIC<- AIC(m[[i]])
#     tabel <- c(tabel,round(AIC))}
# chosenModel<-m[which(tabel == min(tabel))]
#    Anova_1 <- Anova(chosenModel[[1]])
#    cat(sprintf("\nAnova\n"))
#    an<-Anova_1
})
output$Anova <- renderPrint({
p()
})
em <- reactive({
tabel<-c()
for (i in 1:length(models())){
AIC<- AIC(models()[[i]])
tabel <- c(tabel,round(AIC))}
chosenModel<-models()[which(tabel == min(tabel))]
cat(sprintf("\nemmeans of formula: %s\n", input$formula_choice))
if ((grepl("TestMoment", input$formula_choice)==FALSE)){
emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
}else{
emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
}
# tabel <- c()
#     for (i in 1:length(m)){
#   AIC<- AIC(m[[i]])
#   tabel <- c(tabel,round(AIC))}
# chosenModel<-m[which(tabel == min(tabel))]
# cat(sprintf("\nemmeans of formula: %s\n", Formula))
# if ((grepl("TestMoment", Formula)==FALSE)){
#  em<- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
# }else{
#   em<-  emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
# }
#
})
output$emmeans <- renderPrint({
em()
})
}
shinyApp(ui=ui, server=server, options= list(height=800))
knitr::opts_chunk$set(dev = "png",
fig.path='Z:\\shares\\ghepmk_data\\2020_Kappen_PMS\\figures\\',
dpi = 300,
cache = FALSE)
library(Rmisc)
library(raincloudplots)
install.packages("raincloudplots")
library(lme4)
library(lmerTest)
library(effects)
library(dplyr)
library(car)
library(emmeans)
library(fitdistrplus)
library(gplots)
library(ggplot2)
library(ggstatsplot)
library(ggsignif)
library(ggformula)
library(ggdist)
library(ggpubr)
library(ggeffects)
library(gridExtra)
library(tidyverse)
library(pander)
library(stringr)
library(cowplot)
library(lavaan)
library(readr)
library(jpeg)
library(shiny)
library(reshape2)
library (yarrr)
library(knitr)
library(remotes)
install.packages("raincloudplots")
library(MASS)
library(reshape2)
# define covariance matrix of v1-v10 in class 1
# diagonal: variances of v1-v10
# off-diagonal: covariances between v1-v10
Sigma1 <- rbind(c(1.0,0.0,0.2,0.1,0.1,0.3,0.1,0.2,0.1,0.1),
c(0.0,1.1,0.1,0.2,0.1,0.2,0.2,0.3,0.2,0.1),
c(0.2,0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,2.0,0.2,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.2,2.8,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.2,0.1,0.1,0.2,1.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,2.0,0.1,0.2,0.1),
c(0.2,0.3,0.2,0.1,0.1,0.2,0.1,1.0,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,1.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,1.0))
# simulate class 1 responses (v1-v10), based on means (mu)
17
# simulate class 1 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl1 <-mvrnorm(100, mu=c(2,3,2,6,7,4,5,8,2,1), Sigma=Sigma1)
#########################################################
####### define covariance matrix of v1-v10 in class 2 ###
Sigma2 <- rbind(c(2.0,0.1,0.2,0.1,0.1,0.3,0.1,0.2,0.1,0.1),
c(0.1,1.5,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,1.5,0.2,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.2,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,2.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.2,0.3,0.2,0.1,0.1,0.2,0.1,2.0,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,1.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,1.5))
# simulate class 2 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl2 <-mvrnorm(110, mu=c(6,7,1,3,2,8,3,8,2,5), Sigma=Sigma2)
##########################################################
######## define covariance matrix of v1-v10 in class 3 ###
Sigma3 <- rbind(c(1.0,0.1,0.2,0.1,0.1,0.3,0.1,0.3,0.1,0.1),
c(0.1,1.0,0.1,0.2,0.1,0.1,0.2,0.3,0.2,0.1),
c(0.2,0.1,2.2,0.1,0.2,0.1,0.1,0.2,0.1,0.2),
c(0.1,0.2,0.1,2.0,0.1,0.1,0.2,0.1,0.2,0.1),
c(0.1,0.1,0.2,0.1,1.0,0.2,0.1,0.1,0.2,0.1),
c(0.3,0.1,0.1,0.1,0.2,1.0,0.3,0.2,0.0,0.1),
c(0.1,0.2,0.1,0.2,0.1,0.3,1.0,0.1,0.2,0.1),
c(0.3,0.3,0.2,0.1,0.1,0.2,0.1,1.2,0.2,0.1),
c(0.1,0.2,0.1,0.2,0.2,0.0,0.2,0.2,3.0,0.2),
c(0.1,0.1,0.2,0.1,0.1,0.1,0.1,0.1,0.2,2.0))
# simulate class 3 responses (v1-v10), based on means (mu)
# and covariance matrix (sigma)
set.seed(0111)
cl3 <-mvrnorm(90, mu=c(2,5,8,7,5,2,1,4,9,8), Sigma=Sigma3)
##########################################################
### convert matrices to data.frame objects & add a class nr
cl1 <- as.data.frame(cl1)
cl1$class <-rep(1,100)
cl2 <- as.data.frame(cl2)
cl2$class <-rep(2,110)
cl3 <- as.data.frame(cl3)
cl3$class <- rep(3,90)
View(cl3)
# merge the three class dataframes and add ID numbers
dat1 <- rbind(cl1,cl2,cl3)
colnames(dat1) <- c('var1', 'var2', 'var3', 'var4', 'var5',
'var6', 'var7', 'var8', 'var9', 'var10',
'class')
dat1$class <- as.factor(dat1$class)
View(dat1)
dat1$id <- seq(1,300,1)
##########################################################
### add a little stochastic noise for increased realism ;)
dat1$var1 <- dat1$var1 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var2 <- dat1$var2 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var3 <- dat1$var3 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var4 <- dat1$var4 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var5 <- dat1$var5 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var6 <- dat1$var6 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var7 <- dat1$var7 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var8 <- dat1$var8 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var9 <- dat1$var9 + rnorm(n=300, mean=0, sd=sqrt(1))
dat1$var10 <- dat1$var10 + rnorm(n=300, mean=0, sd=sqrt(1))
# Visualize real quick
ggplot(data, aes(group=id, color=class)) +
geom_line()
# Visualize real quick
library(ggplot2)
ggplot(data, aes(group=id, color=class)) +
geom_line()
ggplot(dat1, aes(group=id, color=class)) +
geom_line()
library(babynames)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
idvar= c('id'))
View(dat2)
# Get to long format
dat2 <- reshape(dat1, direction='long', # Transform dataframe to long format
varying=list(c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10")),
timevar='variables',
times=c("var1", "var2", "var3", "var4", "var5", "var6", "var7", "var8", "var9", "var10"),
v.names=c('Value'),
idvar= c('id'))
# Visualize real quick
library(ggplot2)
ggplot(dat2, aes(x = variables, y = Value, group=id, color=class)) +
geom_line()
########### MClust ####
library(mclust)
install.packages("mclust")
mnames <- c("EEI", "EEE", "VVI", "VVV")
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
########### MClust ####
library(mclust)
# Fit 1-5 class model
mod_g1_9 <- Mclust(dat1[, 1:10], modelNames = mnames)
View(mod_g1_9)
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC
mod_g1_9$loglik
mod_g1_9$df
BIC = 2(−5951.275) − 42(log(300)) = −12142.11
BIC = 2(-5951.275) - 42(log(300))
BIC = 2*(-5951.275) - 42(log(300))
42(log(300))
42*(log(300))
BIC = 2*(-5951.275) - 42*(log(300))
BIC
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
mod_g1_9$z
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification
mod_g1_9$uncertainty
# Check max and mean uncertainty over all participants
max(mod_g1_9$uncertainty)
mean(mod_g1_9$uncertainty)
# Plot or tabulate uncertainty per class to gain further insight
cprob <- cbind(mod_g1_9$z, mod_g1_9$classification)
cprob <- as.data.frame(cprob)
colnames(cprob) <- c("prob (class 1)", "prob (class 2)", "prob (class 3)", "class")
aggregate(cprob[, 1:3], list(cprob$class), mean)
install.packages("tidyLPA")
# Predict LPA models with 1-9 classes, with an EI config:
suppressMessages(library(tidyLPA))
suppressMessages(mod_1c_v1 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = 1))
mod_1c_v1
# Optimal model variant
mod_g1_9$modelName
# Opimal number of classes
mod_g1_9$G
# Optimal model variant
mod_g1_9$modelName
# Check all model's / class numbers BIC's
mod_g1_9$BIC # Maybe weird that negative, but: BIC = 2(Loglikelihood) − df(log(n))
mod_g1_9$loglik
mod_g1_9$df
BIC = 2*(-5951.275) - 42*(log(300)) # See?, same BIC!
# tabulate class-membership numbers
table(summary(mod_g1_9)$classification)
# display the means per class
mod_g1_9$parameters$mean
# select the first of 3 10-by-10 variance matrices
mod_g1_9$parameters$variance$sigma[1:10, 1:10, 1]
# mod_g1_9$z # Each subjects probability to be part of a certain estimated class
mod_g1_9$classification # Leading to a class classification matrix; posterior allocation
mod_g1_9$uncertainty # WATCH OUT, only use classification if it is a clear cut case which class a participant belongs to. Else; use uncertainty indices.
suppressMessages(mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9,
models = c(1,2,3,6)))
# Let's try to fix all variable covariances to zero
mod_1c_v2 <- estimate_profiles(df = dat1[1:10], n_profiles = 1:9, variances = "equal",
covariances = "zero")
mod_1c_v2$model_1_class_2$fit
# Compare model fits (for v1)
comp <- suppressWarnings(compare_solutions(mod_1c_v1))
comp$fits
comp$best
# Load in packages
install.packages("foreign")
install.packages("ggplot2")
install.packages("MASS")
# Load in packages
library(car)
library(lme4)
library(arrow) # Parquets
library(readr) # Delims
library(reshape2)
library(plotly)
library(dplyr)
library(emmeans)
library(ggplot2)
library(effects)
##### Set environment #####
rm(list = ls()) # Clear environment
cat("\014") # Clear console # # Or ctrl + l in VSCode
dev.off() # Clear plot window
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
plotDirectory = dirname(rstudioapi::getActiveDocumentContext()$path)
source("functions.R") # Load document where functions are stored
options(contrasts = c("contr.sum","contr.poly")) #use this for the p value of the t test
nAGQ = 1
plotPrefix <- "/../figures/"
pvalues = c() # Create a variable to store all p-values to correct later
# De-double transcripts
transcriptData <- as.data.frame(read_parquet("E:/Data/2020_ResonanceBreathing/Data/Interim/Audio/df_transcripts.parquet"))
View(transcriptData)
transcriptData[transcriptData$pptNum == 1 & transcriptData$phaseNum == 4, ]
test = transcriptData[transcriptData$pptNum == 1 & transcriptData$phaseNum == 4, ]
test[0]
test[1]
test[2]
test[3]
test[5]
test[5,1]
test[5,2]
test[5]
test[3,5]
test[1,5]
test[1,5] == test[3,5]
test[1,5] == test[2,5]
uniqueData <- transcriptData[!duplicated(transcriptData[c("pptNum", "phaseNum")]), ]
View(uniqueData)
uniqueData$phaseName[phaseNum == 1] = 'Habituation'
uniqueData$phaseName[uniqueData$phaseNum == 1] = 'Habituation'
uniqueData$phaseName[uniqueData$phaseNum == 2] = 'Breathing'
uniqueData$phaseName[uniqueData$phaseNum == 3] = 'Calculus'
uniqueData$phaseName[uniqueData$phaseNum == 4] = 'SART'
uniqueData$phaseName[uniqueData$phaseNum == 5] = 'PassiveViewing'
# Write file
write_parquet(uniqueData, "E:/Data/2020_ResonanceBreathing/Data/Interim/Audio/df_transcripts_cleaned.parquet")
